---
phase: 04-shadow-mode
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - bond/graph/nodes/shadow_checkpoint.py
  - bond/graph/graph.py
  - bond/api/main.py
  - frontend/src/components/ShadowPanel.tsx
  - frontend/src/components/AnnotationList.tsx
  - frontend/src/hooks/useSyncScroll.ts
  - frontend/package.json
  - frontend/src/components/ChatInterface.tsx
autonomous: false
requirements:
  - SHAD-05
  - SHAD-06

must_haves:
  truths:
    - "shadow_checkpoint_node uses interrupt() to surface annotation list, corrected text, and iteration count to the frontend; it does NOT contain any LLM call (separate node from shadow_annotate_node)"
    - "On rejection, the graph loops back to shadow_annotate_node with shadow_rejected_ids and shadow_rejection_reason populated; only rejected annotation IDs are regenerated"
    - "Soft-cap at 3 iterations: when shadow_iterations >= 3, the interrupt payload includes a max_iterations_reached flag but still allows the user to approve or reject (consistent with Author mode cp2 pattern)"
    - "FastAPI /api/chat/stream accepts mode='shadow' and shadow_input_text in the initial state payload without requiring a new endpoint"
    - "ShadowPanel renders two panes side-by-side: annotated original on the left, corrected version on the right using react-diff-viewer-continued v4.1.2 in splitView mode"
    - "useSyncScroll hook synchronizes scroll position between the two diff panes; includes guard log if fewer than 2 pane elements are found"
    - "Corrected version is displayed in an editable textarea sibling to the diff viewer (not inside the read-only diff table)"
    - "'Copy corrected' button copies the corrected text to the clipboard"
    - "AnnotationList renders each annotation with its original_span, replacement, reason, and a Reject checkbox; new/modified annotations are visually highlighted (green border or badge)"
    - "User can reject individual annotations by checking their checkboxes, enter free-text feedback, and submit — triggering graph resume via /api/chat/resume with rejected_ids and reason"
  artifacts:
    - path: "bond/graph/nodes/shadow_checkpoint.py"
      provides: "shadow_checkpoint_node — interrupt() only, no LLM call; handles approve/reject routing"
      exports: ["shadow_checkpoint_node"]
    - path: "bond/api/main.py"
      provides: "shadow mode state init in /api/chat/stream — mode, shadow_input_text, and all shadow_* fields defaulted to None"
      contains: "shadow_input_text"
    - path: "bond/graph/graph.py"
      provides: "route_after_shadow_cp conditional edge wiring — shadow_checkpoint → END on approval, → shadow_annotate on rejection"
      contains: "route_after_shadow_cp"
    - path: "frontend/src/components/ShadowPanel.tsx"
      provides: "Side-by-side split pane display with synchronized scroll, editable corrected pane, copy button"
      exports: ["ShadowPanel"]
    - path: "frontend/src/components/AnnotationList.tsx"
      provides: "Per-annotation reject UI with status highlighting and feedback submission"
      exports: ["AnnotationList"]
    - path: "frontend/src/hooks/useSyncScroll.ts"
      provides: "Custom scroll sync hook for react-diff-viewer-continued panes"
      exports: ["useSyncScroll"]
    - path: "frontend/src/components/ChatInterface.tsx"
      provides: "Phase 3 ChatInterface updated to conditionally render ShadowPanel and AnnotationList when mode='shadow'"
      contains: "ShadowPanel"
  key_links:
    - from: "bond/graph/nodes/shadow_checkpoint.py"
      to: "langgraph.types.interrupt"
      via: "interrupt() call"
      pattern: "from langgraph\\.types import interrupt"
    - from: "bond/graph/graph.py"
      to: "shadow_checkpoint_node"
      via: "add_conditional_edges('shadow_checkpoint', route_after_shadow_cp, ...)"
      pattern: "route_after_shadow_cp"
    - from: "frontend/src/components/ShadowPanel.tsx"
      to: "react-diff-viewer-continued"
      via: "import ReactDiffViewer"
      pattern: "react-diff-viewer-continued"
    - from: "frontend/src/components/AnnotationList.tsx"
      to: "/api/chat/resume"
      via: "fetch POST with rejected_ids and reason"
      pattern: "api/chat/resume"
    - from: "frontend/src/components/ChatInterface.tsx"
      to: "frontend/src/components/ShadowPanel.tsx"
      via: "conditional render when chatStore.mode === 'shadow' and interrupt payload contains annotations"
      pattern: "mode.*shadow.*ShadowPanel|ShadowPanel.*mode.*shadow"
---

<objective>
Complete Shadow mode: implement the HITL checkpoint node with per-annotation reject/regenerate loop, wire the full Shadow branch in graph.py, update the FastAPI endpoint to accept shadow mode inputs, and build the frontend dual-output display with annotation rejection UI.

Purpose: Plan 01 built the analysis and annotation nodes. This plan closes the loop with the HITL interrupt + routing and delivers the two frontend components users interact with (SHAD-05, SHAD-06). Ends with a human verification checkpoint of the full end-to-end Shadow mode flow.
Output: Fully working Shadow mode: backend HITL loop, frontend split pane, annotation rejection, end-to-end smoke test.
</objective>

<execution_context>
@/Users/franciszekmarzynski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/franciszekmarzynski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-shadow-mode/04-CONTEXT.md
@.planning/phases/04-shadow-mode/04-RESEARCH.md
@.planning/phases/04-shadow-mode/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: shadow_checkpoint_node, full Shadow branch wiring, FastAPI shadow state init</name>
  <files>
    bond/graph/nodes/shadow_checkpoint.py
    bond/graph/graph.py
    bond/api/main.py
  </files>
  <action>
**1. bond/graph/nodes/shadow_checkpoint.py — interrupt-only node**

CRITICAL: This node contains ONLY the interrupt() call. No LLM logic here. Mixing LLM calls with interrupt() causes the LLM to re-execute on graph resume (confirmed pitfall from Phase 2 HITL pattern).

```python
"""Shadow checkpoint node — interrupt only, no LLM calls."""
from __future__ import annotations

from langgraph.types import interrupt


def shadow_checkpoint_node(state: dict) -> dict:
    """Surface annotation list to the frontend via interrupt().

    Payload surfaced to frontend:
    - annotations: list of Annotation dicts (with 'status' field after regeneration rounds)
    - corrected_text: full corrected version assembled by shadow_annotate_node
    - shadow_iterations: current iteration count (frontend shows soft-cap warning at >= 3)
    - alignment_summary: optional summary string (empty string if not applicable)
    - max_iterations_reached: True when shadow_iterations >= 3 (informational; not a hard block)

    Resume payload expected from frontend:
    - {"approved": True} — user accepts all current annotations
    - {"approved": False, "rejected_ids": ["ann_003", ...], "reason": "..."}
    """
    max_iter = 3
    iterations = state.get("shadow_iterations", 0)

    user_response = interrupt({
        "annotations": state.get("shadow_annotations") or [],
        "corrected_text": state.get("shadow_corrected_text") or "",
        "shadow_iterations": iterations,
        "alignment_summary": "",
        "max_iterations_reached": iterations >= max_iter,
    })

    if user_response.get("approved"):
        return {"shadow_cp_approved": True}
    else:
        return {
            "shadow_cp_approved": False,
            "shadow_rejected_ids": user_response.get("rejected_ids") or [],
            "shadow_rejection_reason": user_response.get("reason") or "",
            "shadow_iterations": iterations + 1,
        }
```

**2. bond/graph/graph.py — replace shadow_checkpoint_stub, finalize Shadow branch wiring**

a) Add import at the top of graph.py:
```python
from bond.graph.nodes.shadow_checkpoint import shadow_checkpoint_node
```

b) Add routing function for after Shadow checkpoint (add alongside the other `_route_after_*` functions):
```python
def route_after_shadow_cp(state: "BondState") -> str:
    """Route to END on approval; loop back to shadow_annotate on rejection.

    Soft cap: when shadow_iterations >= 3, still allow one more attempt consistent
    with Author mode cp2 pattern. The interrupt payload carries max_iterations_reached=True
    so the frontend can show a warning, but the user decides whether to continue.
    """
    if state.get("shadow_cp_approved"):
        return END
    return "shadow_annotate"
```

c) In `build_author_graph` / `build_bond_graph`, replace `builder.add_node("shadow_checkpoint", _shadow_checkpoint_stub)` with:
```python
builder.add_node("shadow_checkpoint", shadow_checkpoint_node)
```

d) Replace the stub `builder.add_edge("shadow_checkpoint", END)` with conditional routing:
```python
builder.add_conditional_edges(
    "shadow_checkpoint",
    route_after_shadow_cp,
    {"shadow_annotate": "shadow_annotate", END: END},
)
```

Remove `builder.add_edge("shadow_annotate", "shadow_checkpoint")` stub if still present — it should already exist from Plan 04-01. Verify graph has:
```
shadow_analyze → shadow_annotate → shadow_checkpoint → (approved: END | rejected: shadow_annotate)
```

**3. bond/api/main.py — handle shadow mode initial state**

Read the existing FastAPI app from Phase 3. In the `/api/chat/stream` SSE endpoint, the initial state dict is assembled from the request body. Add shadow mode handling:

In the initial state assembly (wherever `thread_id`, `topic`, `keywords` etc. are read from the request body), add:

```python
# Shadow mode: if mode == "shadow", populate shadow fields; author fields default to None/empty
mode = body.get("mode", "author")
initial_state: dict = {
    "mode": mode,
    "thread_id": thread_id,
    # Author mode fields (required by BondState schema; unused in Shadow branch)
    "topic": body.get("topic"),
    "keywords": body.get("keywords") or [],
    "search_cache": {},
    "cp1_iterations": 0,
    "cp2_iterations": 0,
    "metadata_saved": False,
    "duplicate_match": None,
    "duplicate_override": None,
    "research_report": None,
    "heading_structure": None,
    "cp1_approved": None,
    "cp1_feedback": None,
    "draft": None,
    "draft_validated": None,
    "cp2_approved": None,
    "cp2_feedback": None,
    # Shadow mode fields
    "shadow_input_text": body.get("shadow_input_text") if mode == "shadow" else None,
    "shadow_iterations": 0,
    "shadow_cp_approved": None,
    "shadow_corpus_fragments": None,
    "shadow_annotations": None,
    "shadow_corrected_text": None,
    "shadow_rejected_ids": None,
    "shadow_rejection_reason": None,
    "shadow_previous_annotations": None,
}
```

No new endpoints are needed — the existing `/api/chat/resume` endpoint already accepts `Command(resume=payload)` and works for Shadow mode rejection/approval without changes.
  </action>
  <verify>
```bash
cd /Users/franciszekmarzynski/Downloads/Bond-agent

# Verify shadow_checkpoint_node imports correctly
python -c "
from bond.graph.nodes.shadow_checkpoint import shadow_checkpoint_node
print('shadow_checkpoint_node importable:', shadow_checkpoint_node)
"

# Verify graph compiles with final Shadow branch wiring
python -c "
from bond.graph.graph import compile_graph
graph = compile_graph()
nodes = set(graph.nodes.keys())
required = {'shadow_analyze', 'shadow_annotate', 'shadow_checkpoint'}
assert required.issubset(nodes), f'Missing shadow nodes: {required - nodes}'
print('Full graph with Shadow branch ok. Nodes:', sorted(nodes))
"

# Verify FastAPI app starts without import errors
python -c "
import importlib, sys
try:
    mod = importlib.import_module('bond.api.main')
    print('bond.api.main imports ok')
except ImportError as e:
    print('Import error (check if Phase 3 API exists yet):', e)
"
```
shadow_checkpoint_node imports successfully. Graph compiles with shadow_checkpoint in nodes. FastAPI main imports without error (or prints informative message if Phase 3 API is not yet implemented — acceptable since this plan only modifies initial_state assembly).
  </verify>
  <done>shadow_checkpoint_node is a pure interrupt() node with no LLM calls. Graph has correct Shadow branch: shadow_analyze → shadow_annotate → shadow_checkpoint → (approved: END | rejected: shadow_annotate loop). FastAPI /api/chat/stream initial state assembly includes shadow_input_text and all required shadow fields. No new API endpoints are added.</done>
</task>

<task type="auto">
  <name>Task 2: ShadowPanel, AnnotationList, useSyncScroll — frontend dual-output display</name>
  <files>
    frontend/package.json
    frontend/src/components/ShadowPanel.tsx
    frontend/src/components/AnnotationList.tsx
    frontend/src/hooks/useSyncScroll.ts
  </files>
  <action>
**0. Install react-diff-viewer-continued**

```bash
cd frontend && npm install react-diff-viewer-continued@4.1.2
```

Pin to 4.1.2 explicitly — `useSyncScroll` targets the internal DOM structure of this version; an unverified upgrade could break scroll sync.

**1. frontend/src/hooks/useSyncScroll.ts — synchronized scroll hook**

```typescript
import { useEffect } from "react";

/**
 * Synchronizes scroll position between the two panes rendered by react-diff-viewer-continued
 * in splitView mode. The library renders two <table> elements inside a container div.
 *
 * Pitfall: targets internal DOM structure of react-diff-viewer-continued@4.1.2.
 * If scroll sync breaks after an npm upgrade, verify that the library still renders
 * two <table> elements in the split view container.
 */
export function useSyncScroll(containerRef: React.RefObject<HTMLElement | null>) {
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const panes = container.querySelectorAll("table");
    if (panes.length < 2) {
      console.warn(
        "[useSyncScroll] Expected 2 table panes inside diff viewer container, found:",
        panes.length,
        "— scroll sync disabled. Check react-diff-viewer-continued DOM structure after upgrades."
      );
      return;
    }

    const [left, right] = [panes[0], panes[1]] as [HTMLElement, HTMLElement];
    let isSyncing = false;

    const syncFromLeft = () => {
      if (isSyncing) return;
      isSyncing = true;
      right.scrollTop = left.scrollTop;
      isSyncing = false;
    };
    const syncFromRight = () => {
      if (isSyncing) return;
      isSyncing = true;
      left.scrollTop = right.scrollTop;
      isSyncing = false;
    };

    left.addEventListener("scroll", syncFromLeft);
    right.addEventListener("scroll", syncFromRight);
    return () => {
      left.removeEventListener("scroll", syncFromLeft);
      right.removeEventListener("scroll", syncFromRight);
    };
  }, [containerRef]);
}
```

**2. frontend/src/components/ShadowPanel.tsx — split-pane dual output**

The annotated original shows the text with inline annotation markers (rendered as the diff viewer's left/old side). The corrected version shows the fully applied corrections (right/new side).

IMPORTANT per CONTEXT.md decisions:
- Side-by-side split pane: annotated on left, corrected on right
- Synchronized scroll (via useSyncScroll hook)
- Corrected version pane is editable — backed by a controlled textarea NEXT TO (not inside) the diff viewer, because react-diff-viewer-continued renders read-only tables
- "Copy corrected" button

```typescript
"use client";

import React, { useRef, useState } from "react";
import ReactDiffViewer from "react-diff-viewer-continued";
import { useSyncScroll } from "../hooks/useSyncScroll";

interface ShadowPanelProps {
  /** Original submitted text with inline annotation markers inserted */
  annotatedText: string;
  /** Fully corrected version (all annotations applied) */
  correctedText: string;
  /** Whether this is a regeneration round (shows 'Updated' badge) */
  isRegeneration?: boolean;
}

export function ShadowPanel({
  annotatedText,
  correctedText,
  isRegeneration = false,
}: ShadowPanelProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [editedCorrected, setEditedCorrected] = useState(correctedText);
  const [copyLabel, setCopyLabel] = useState("Copy corrected");

  // Update editable text when corrected version changes (after regeneration)
  React.useEffect(() => {
    setEditedCorrected(correctedText);
  }, [correctedText]);

  useSyncScroll(containerRef);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(editedCorrected);
      setCopyLabel("Copied!");
      setTimeout(() => setCopyLabel("Copy corrected"), 2000);
    } catch {
      // Fallback for non-secure contexts
      const el = document.createElement("textarea");
      el.value = editedCorrected;
      document.body.appendChild(el);
      el.select();
      document.execCommand("copy");
      document.body.removeChild(el);
      setCopyLabel("Copied!");
      setTimeout(() => setCopyLabel("Copy corrected"), 2000);
    }
  };

  return (
    <div className="shadow-panel flex flex-col gap-4">
      {isRegeneration && (
        <div className="text-xs text-green-600 font-medium px-1">
          Updated — green highlights show new or modified corrections
        </div>
      )}

      {/* Split-pane diff view (read-only, for visual comparison) */}
      <div ref={containerRef} className="shadow-diff-container border rounded overflow-hidden">
        <ReactDiffViewer
          oldValue={annotatedText}
          newValue={correctedText}
          splitView={true}
          hideLineNumbers={true}
          compareMethod="diffWords"
          leftTitle="Annotated original"
          rightTitle="Corrected version"
        />
      </div>

      {/* Editable corrected pane — separate from the read-only diff viewer */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center justify-between">
          <label className="text-sm font-medium text-gray-700">
            Corrected version (editable)
          </label>
          <button
            onClick={handleCopy}
            className="text-sm px-3 py-1 border rounded hover:bg-gray-50 transition-colors"
          >
            {copyLabel}
          </button>
        </div>
        <textarea
          value={editedCorrected}
          onChange={(e) => setEditedCorrected(e.target.value)}
          className="w-full min-h-[200px] p-3 border rounded font-mono text-sm resize-y focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="Corrected version will appear here..."
        />
      </div>
    </div>
  );
}
```

**3. frontend/src/components/AnnotationList.tsx — per-annotation rejection UI**

Per CONTEXT.md decisions:
- Per-annotation rejection — user can dismiss individual annotations; only rejected ones regenerate
- Free text only for rejection reason
- After regeneration: highlight new/modified annotations (use the 'status' field set by _mark_annotation_status in shadow_annotate_node)

```typescript
"use client";

import React, { useState } from "react";

export interface AnnotationItem {
  annotation_id: string;
  original_span: string;
  replacement: string;
  reason: string;
  /** Set by shadow_annotate_node on regeneration rounds */
  status?: "new" | "modified" | "unchanged";
}

interface AnnotationListProps {
  annotations: AnnotationItem[];
  threadId: string;
  iterationsUsed: number;
  maxIterations?: number;
  maxIterationsReached?: boolean;
  onApproved: () => void;
  onRejectionSubmitted: () => void;
}

export function AnnotationList({
  annotations,
  threadId,
  iterationsUsed,
  maxIterations = 3,
  maxIterationsReached = false,
  onApproved,
  onRejectionSubmitted,
}: AnnotationListProps) {
  const [rejectedIds, setRejectedIds] = useState<Set<string>>(new Set());
  const [reason, setReason] = useState("");
  const [submitting, setSubmitting] = useState(false);

  const toggleReject = (id: string) => {
    setRejectedIds((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const handleApprove = async () => {
    setSubmitting(true);
    await fetch("/api/chat/resume", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ thread_id: threadId, response: { approved: true } }),
    });
    onApproved();
    setSubmitting(false);
  };

  const handleSubmitRejections = async () => {
    if (rejectedIds.size === 0) return;
    setSubmitting(true);
    await fetch("/api/chat/resume", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        thread_id: threadId,
        response: {
          approved: false,
          rejected_ids: Array.from(rejectedIds),
          reason,
        },
      }),
    });
    setRejectedIds(new Set());
    setReason("");
    onRejectionSubmitted();
    setSubmitting(false);
  };

  const statusBadgeClass = (status?: string) => {
    if (status === "new") return "bg-green-100 border-green-400";
    if (status === "modified") return "bg-yellow-100 border-yellow-400";
    return "";
  };

  return (
    <div className="annotation-list flex flex-col gap-4">
      <div className="flex items-center justify-between">
        <h3 className="font-semibold text-sm text-gray-800">
          Annotations ({annotations.length})
        </h3>
        {iterationsUsed > 0 && (
          <span className="text-xs text-gray-500">
            {iterationsUsed} of {maxIterations} regeneration{iterationsUsed !== 1 ? "s" : ""} used
          </span>
        )}
      </div>

      {maxIterationsReached && (
        <div className="text-xs text-amber-600 bg-amber-50 border border-amber-200 rounded p-2">
          Maximum regenerations reached. You can still approve or reject — the agent will attempt one more round.
        </div>
      )}

      <ul className="flex flex-col gap-2">
        {annotations.map((ann) => (
          <li
            key={ann.annotation_id}
            className={`border rounded p-3 text-sm ${statusBadgeClass(ann.status)}`}
          >
            <div className="flex items-start gap-3">
              <input
                type="checkbox"
                id={`reject-${ann.annotation_id}`}
                checked={rejectedIds.has(ann.annotation_id)}
                onChange={() => toggleReject(ann.annotation_id)}
                className="mt-1 shrink-0"
                aria-label={`Reject annotation ${ann.annotation_id}`}
              />
              <div className="flex flex-col gap-1 flex-1 min-w-0">
                {ann.status && ann.status !== "unchanged" && (
                  <span className="text-xs font-medium capitalize text-green-700">
                    {ann.status}
                  </span>
                )}
                <div className="flex gap-2 flex-wrap">
                  <span className="text-red-700 line-through text-xs font-mono break-all">
                    {ann.original_span}
                  </span>
                  <span className="text-gray-400 text-xs">→</span>
                  <span className="text-green-700 text-xs font-mono break-all">
                    {ann.replacement}
                  </span>
                </div>
                <p className="text-gray-500 text-xs italic">{ann.reason}</p>
              </div>
            </div>
          </li>
        ))}
      </ul>

      {rejectedIds.size > 0 && (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-gray-700">
            Feedback for rejected annotations (optional)
          </label>
          <textarea
            value={reason}
            onChange={(e) => setReason(e.target.value)}
            placeholder="Explain what you'd like changed..."
            className="w-full p-2 border rounded text-sm resize-y min-h-[60px] focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button
            onClick={handleSubmitRejections}
            disabled={submitting}
            className="self-start px-4 py-2 bg-orange-500 text-white text-sm rounded hover:bg-orange-600 disabled:opacity-50 transition-colors"
          >
            {submitting ? "Regenerating…" : `Regenerate ${rejectedIds.size} annotation${rejectedIds.size !== 1 ? "s" : ""}`}
          </button>
        </div>
      )}

      <div className="flex gap-3 pt-2 border-t">
        <button
          onClick={handleApprove}
          disabled={submitting}
          className="px-4 py-2 bg-green-600 text-white text-sm rounded hover:bg-green-700 disabled:opacity-50 transition-colors"
        >
          {submitting ? "Saving…" : "Approve all"}
        </button>
        {rejectedIds.size === 0 && (
          <p className="text-xs text-gray-400 self-center">
            Check annotations to reject individual suggestions before approving
          </p>
        )}
      </div>
    </div>
  );
}
```
  </action>
**4. frontend/src/components/ChatInterface.tsx — wire ShadowPanel and AnnotationList into the Phase 3 shell**

Read the Phase 3 ChatInterface (built in Phase 3 Plan 02). Locate the section that renders the interrupt payload for Author mode checkpoints (cp1/cp2). Add a parallel branch for shadow mode interrupts:

a) Add imports at the top of ChatInterface.tsx:
```typescript
import { ShadowPanel } from "./ShadowPanel";
import { AnnotationList } from "./AnnotationList";
```

b) Inside the interrupt-payload rendering logic (where `interruptPayload` is consumed), add a conditional block that renders Shadow components when `chatStore.mode === 'shadow'` AND the interrupt payload contains an `annotations` field:
```typescript
{chatStore.mode === 'shadow' && interruptPayload?.annotations != null ? (
  <div className="shadow-mode-output flex flex-col gap-6">
    <ShadowPanel
      annotatedText={chatStore.inputText ?? ""}
      correctedText={interruptPayload.corrected_text ?? ""}
      isRegeneration={(interruptPayload.shadow_iterations ?? 0) > 0}
    />
    <AnnotationList
      annotations={interruptPayload.annotations}
      threadId={chatStore.threadId}
      iterationsUsed={interruptPayload.shadow_iterations ?? 0}
      maxIterationsReached={interruptPayload.max_iterations_reached ?? false}
      onApproved={() => chatStore.resetAfterApproval()}
      onRejectionSubmitted={() => chatStore.setAwaitingStream(true)}
    />
  </div>
) : null}
```

IMPORTANT: Use the exact state field names and store method calls that exist in the Phase 3 ChatInterface. If `chatStore.inputText` is named differently (e.g., `chatStore.shadowInputText` or passed as a prop), use the correct name from the Phase 3 SUMMARY. The pattern above shows intent — adapt to the actual API surface.

Do NOT modify the existing Author mode checkpoint rendering (cp1/cp2 blocks). The Shadow block is additive — a new `if mode === 'shadow'` branch.
  </action>
  <verify>
```bash
cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend

# Verify react-diff-viewer-continued installed
node -e "const p = require('./node_modules/react-diff-viewer-continued/package.json'); console.log('react-diff-viewer-continued version:', p.version)"

# TypeScript type-check the new components (if tsc is available)
npx tsc --noEmit 2>&1 | grep -E "ShadowPanel|AnnotationList|useSyncScroll|ChatInterface" || echo "No TS errors in Shadow components"

# Verify component files exist including ChatInterface update
ls src/components/ShadowPanel.tsx src/components/AnnotationList.tsx src/hooks/useSyncScroll.ts src/components/ChatInterface.tsx

# Verify ChatInterface imports ShadowPanel
grep -n "ShadowPanel" src/components/ChatInterface.tsx
```
react-diff-viewer-continued is at version 4.1.2. All four component files exist at expected paths. ChatInterface.tsx contains an import for ShadowPanel. TypeScript check passes for Shadow components (or shows only unrelated pre-existing errors).
  </verify>
  <done>react-diff-viewer-continued@4.1.2 installed in frontend/package.json. ShadowPanel.tsx renders side-by-side diff viewer (read-only) plus editable textarea for corrected version with "Copy corrected" button. useSyncScroll.ts synchronizes scroll with selector guard warning. AnnotationList.tsx renders per-annotation checkboxes with status highlighting, rejection feedback textarea, and Approve/Regenerate buttons that call /api/chat/resume. ChatInterface.tsx conditionally renders ShadowPanel and AnnotationList when chatStore.mode === 'shadow' and the interrupt payload contains an annotations field.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End-to-end Shadow mode smoke test</name>
  <files>N/A — human verification step, no files written</files>
  <action>No automated action — this is a human verification checkpoint. Run the smoke test steps in how-to-verify below.</action>
  <verify>See how-to-verify section below.</verify>
  <done>User types "approved" after confirming end-to-end Shadow mode flow works: text submission → annotation display → per-annotation rejection → regeneration of rejected IDs only → final approval.</done>
  <what-built>
    Full Shadow mode pipeline:
    - Backend: BondState extension, shadow_analyze_node (ChromaDB two-pass), shadow_annotate_node (LLM structured output), shadow_checkpoint_node (HITL interrupt), graph dual-branch routing
    - Frontend: ShadowPanel (split-pane diff, editable corrected, copy button), AnnotationList (per-annotation reject, status highlighting, feedback + regenerate), useSyncScroll hook
    - FastAPI: /api/chat/stream accepts mode='shadow' + shadow_input_text; /api/chat/resume handles per-annotation rejection resume without new endpoints
  </what-built>
  <how-to-verify>
    **Prerequisites:** Phase 3 FastAPI + Next.js frontend must be running. If not yet deployed, run the backend Python test harness instead (see step 6 below).

    **1. Start the backend:**
    ```bash
    cd /Users/franciszekmarzynski/Downloads/Bond-agent
    uvicorn bond.api.main:app --reload --port 8000
    ```

    **2. Start the frontend:**
    ```bash
    cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend
    npm run dev
    ```

    **3. Open http://localhost:3000 and switch to Shadow mode** using the Author/Shadow toggle in the header.

    **4. Paste a sample Polish blog paragraph** into the input field and submit. Expected:
    - Progress indicator shows "Analyzing..." stage
    - After ~5-15 seconds, ShadowPanel appears with two panes side-by-side
    - Left pane: annotated text with corrections shown as word-level diff
    - Right pane: fully corrected version
    - AnnotationList appears below (or alongside) showing all individual annotations
    - Scrolling in either diff pane causes the other pane to scroll in sync

    **5. Test per-annotation rejection:**
    - Check 1-2 annotation checkboxes in AnnotationList
    - Enter feedback text (optional)
    - Click "Regenerate N annotations"
    - Expected: graph resumes, shadow_annotate_node runs for rejected IDs only, new/modified annotations appear with green highlight

    **6. If Phase 3 frontend is not yet available — backend-only test harness:**
    ```bash
    cd /Users/franciszekmarzynski/Downloads/Bond-agent
    python -c "
    from bond.graph.graph import compile_graph
    from langgraph.types import Command

    graph = compile_graph()
    config = {'configurable': {'thread_id': 'shadow-smoke-01'}}

    # Step 1: Start Shadow mode
    state = graph.invoke(
        {
            'mode': 'shadow',
            'thread_id': 'shadow-smoke-01',
            'shadow_input_text': 'To jest bardzo długie i skomplikowane zdanie które wymaga poprawy stylistycznej.',
            'shadow_iterations': 0,
            'shadow_cp_approved': None,
            'search_cache': {},
            'cp1_iterations': 0,
            'cp2_iterations': 0,
            'metadata_saved': False,
        },
        config=config,
    )
    print('Interrupted at shadow_checkpoint. Annotations count:', len(state.get('shadow_annotations') or []))
    print('Corrected text preview:', (state.get('shadow_corrected_text') or '')[:100])

    # Step 2: Approve
    final = graph.invoke(Command(resume={'approved': True}), config=config)
    print('Shadow mode approved. shadow_cp_approved:', final.get('shadow_cp_approved'))
    "
    ```
    Expected output: prints annotation count > 0, corrected text preview, and `shadow_cp_approved: True`.

    **7. Approve all annotations** using the "Approve all" button (or approval command in test harness). Session completes successfully.
  </how-to-verify>
  <resume-signal>Type "approved" if Shadow mode works end-to-end, or describe specific issues (which step failed, error message, unexpected behavior)</resume-signal>
</task>

</tasks>

<verification>
After tasks 1 and 2 complete (before human checkpoint):

```bash
cd /Users/franciszekmarzynski/Downloads/Bond-agent

# Backend: full Shadow branch importable and compilable
python -c "
from bond.graph.graph import compile_graph
from bond.graph.nodes.shadow_checkpoint import shadow_checkpoint_node
from bond.graph.nodes.shadow_analyze import shadow_analyze_node
from bond.graph.nodes.shadow_annotate import shadow_annotate_node, Annotation, AnnotationResult

graph = compile_graph()
nodes = set(graph.nodes.keys())
required = {'shadow_analyze', 'shadow_annotate', 'shadow_checkpoint',
            'duplicate_check', 'researcher', 'structure', 'checkpoint_1',
            'writer', 'checkpoint_2', 'save_metadata'}
missing = required - nodes
assert not missing, f'Missing nodes: {missing}'
print('All 10 nodes present:', sorted(nodes))
"

# Frontend: component files exist and package.json updated
ls /Users/franciszekmarzynski/Downloads/Bond-agent/frontend/src/components/ShadowPanel.tsx
ls /Users/franciszekmarzynski/Downloads/Bond-agent/frontend/src/components/AnnotationList.tsx
ls /Users/franciszekmarzynski/Downloads/Bond-agent/frontend/src/hooks/useSyncScroll.ts
node -e "const p = require('/Users/franciszekmarzynski/Downloads/Bond-agent/frontend/node_modules/react-diff-viewer-continued/package.json'); console.log('Installed:', p.version)"
```
</verification>

<success_criteria>
- shadow_checkpoint_node imports and contains only interrupt() — no LLM calls (verified by code review: no ChatOpenAI, no llm.invoke in shadow_checkpoint.py)
- Graph conditional routing: shadow_checkpoint → approved → END; shadow_checkpoint → rejected → shadow_annotate (loop)
- FastAPI /api/chat/stream initial state dict includes shadow_input_text, shadow_iterations=0, and all other shadow_* fields defaulted to None
- react-diff-viewer-continued@4.1.2 installed in frontend/package.json
- ShadowPanel.tsx renders ReactDiffViewer in splitView mode with annotated text on left and corrected on right
- ShadowPanel.tsx has a separate editable textarea for corrected text (not inside the diff viewer tables)
- ShadowPanel.tsx has "Copy corrected" button that writes to clipboard
- useSyncScroll.ts has guard that logs warning when fewer than 2 pane elements found
- AnnotationList.tsx shows per-annotation checkboxes with status field rendering (new/modified/unchanged)
- AnnotationList.tsx Approve button calls /api/chat/resume with {approved: true}
- AnnotationList.tsx Regenerate button calls /api/chat/resume with {approved: false, rejected_ids: [...], reason: "..."}
- ChatInterface.tsx imports ShadowPanel and AnnotationList and renders them conditionally when chatStore.mode === 'shadow' AND interrupt payload contains annotations field — existing Author mode cp1/cp2 blocks are not modified
- Smoke test (backend harness or full UI) confirms: submit text → annotations returned → partial rejection → regeneration runs only for rejected IDs → approval completes session
</success_criteria>

<output>
After completion, create `.planning/phases/04-shadow-mode/04-02-SUMMARY.md` documenting:
- shadow_checkpoint_node interrupt payload structure
- Shadow branch graph wiring (final conditional edge routing)
- FastAPI shadow mode state initialization
- ShadowPanel split-pane approach (diff viewer + separate editable textarea)
- useSyncScroll DOM selector strategy and version pinning rationale
- AnnotationList per-annotation rejection flow and /api/chat/resume payload format
- Smoke test results and any issues encountered
</output>
