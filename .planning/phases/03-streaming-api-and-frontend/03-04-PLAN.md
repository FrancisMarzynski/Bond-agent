---
phase: 03-streaming-api-and-frontend
plan: 04
type: execute
wave: 2
depends_on:
  - "03-01"
  - "03-02"
files_modified:
  - frontend/src/app/page.tsx
  - frontend/src/components/ChatInterface.tsx
  - frontend/src/components/EditorPane.tsx
  - frontend/src/components/CheckpointPanel.tsx
autonomous: true
requirements:
  - UI-03
  - UI-04
  - UI-05
  - UI-06
  - UI-07

must_haves:
  truths:
    - "User can type a message and send it; the message appears in the chat and the SSE stream starts"
    - "LLM tokens for the writing stage stream directly into the EditorPane as they arrive (live draft build-up)"
    - "Research result appears as a complete assistant message (not token-by-token)"
    - "When hitl_pause arrives, ApproveRejectPanel appears with Approve and Reject buttons"
    - "Reject triggers a chat-style flow: agent message asks what to change, focus moves to chat input"
    - "Checkpoint 2 Reject button shows remaining attempts counter (e.g. '2 of 3 attempts remaining')"
    - "Approve and Approve+Save both POST to /api/chat/resume with the correct action field"
    - "Errors during streaming appear in the chat with a retry button"
  artifacts:
    - path: "frontend/src/components/ChatInterface.tsx"
      provides: "Message list, text input, send button; triggers startStream on submit"
      exports: ["ChatInterface"]
    - path: "frontend/src/components/EditorPane.tsx"
      provides: "@uiw/react-md-editor controlled by Zustand draft state; tokens append live"
      exports: ["EditorPane"]
    - path: "frontend/src/components/CheckpointPanel.tsx"
      provides: "Approve/Reject buttons rendered when hitlPause is non-null; handles all HITL actions"
      exports: ["CheckpointPanel"]
    - path: "frontend/src/app/page.tsx"
      provides: "Main page composing ChatInterface + EditorPane side by side, StageProgress at top, CheckpointPanel above editor when HITL active"
  key_links:
    - from: "frontend/src/components/ChatInterface.tsx"
      to: "frontend/src/hooks/useStream.ts"
      via: "startStream called on form submit"
      pattern: "startStream"
    - from: "frontend/src/components/EditorPane.tsx"
      to: "frontend/src/store/chatStore.ts"
      via: "useChatStore draft selector"
      pattern: "useChatStore.*draft"
    - from: "frontend/src/components/CheckpointPanel.tsx"
      to: "frontend/src/hooks/useStream.ts"
      via: "resumeStream called on approve/reject"
      pattern: "resumeStream"
    - from: "frontend/src/components/CheckpointPanel.tsx"
      to: "frontend/src/store/chatStore.ts"
      via: "useChatStore hitlPause selector"
      pattern: "useChatStore.*hitlPause"
---

<objective>
Build the core chat and editing UI: ChatInterface for message exchange, EditorPane for live streaming draft display, and CheckpointPanel for HITL approve/reject interactions.

Purpose: This plan delivers the user-facing workflow loop — send message → see streaming output → approve or reject at checkpoints. Together these three components implement requirements UI-03, UI-04, UI-05, UI-06, and UI-07.
Output: A functional page where the user can send a topic, watch the agent work through stages, see the draft build up token-by-token in the editor, and approve or reject at each checkpoint.
</objective>

<execution_context>
@/Users/franciszekmarzynski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/franciszekmarzynski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-api-and-frontend/03-CONTEXT.md
@.planning/phases/03-streaming-api-and-frontend/03-RESEARCH.md
@.planning/phases/03-streaming-api-and-frontend/03-02-SUMMARY.md
@.planning/phases/03-streaming-api-and-frontend/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ChatInterface with streaming input and message list</name>
  <files>frontend/src/components/ChatInterface.tsx</files>
  <action>
Create `frontend/src/components/ChatInterface.tsx`. This component owns the left column of the main view: scrolling message history + sticky input bar at the bottom.

Behavior:
- Displays messages from Zustand `messages` array as a scrolling list
- Each message styled differently by role (user = right-aligned bg-primary text, assistant = left-aligned bg-muted)
- Input is a `<textarea>` (shadcn Textarea) that submits on Enter (without Shift) or button click
- On submit: calls `startStream(message, threadId, mode, persistThreadId)` from useStream
- While `isStreaming=true`: disable input, show spinner in send button
- Error messages (role=assistant with content starting "Error:") render with a retry button that re-sends the last user message

**Performance note (Pitfall 7 from RESEARCH.md):** Token appending to draft state causes re-renders. ChatInterface reads `messages` (not `draft`), so it is NOT affected by token streaming. Only EditorPane reads draft.

```tsx
"use client";
import { useRef, useEffect, useState } from "react";
import { useChatStore } from "@/store/chatStore";
import { useSession } from "@/hooks/useSession";
import { startStream } from "@/hooks/useStream";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Loader2, Send } from "lucide-react";
import { cn } from "@/lib/utils";

export function ChatInterface() {
  const { messages, isStreaming, mode } = useChatStore();
  const { threadId, persistThreadId } = useSession();
  const [input, setInput] = useState("");
  const [lastMessage, setLastMessage] = useState("");
  const bottomRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom on new messages
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  const handleSend = async (msg?: string) => {
    const text = (msg ?? input).trim();
    if (!text || isStreaming) return;
    setLastMessage(text);
    setInput("");
    await startStream(text, threadId, mode, persistThreadId);
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  return (
    <div className="flex flex-col h-full">
      {/* Message list */}
      <div className="flex-1 overflow-y-auto p-4 space-y-3">
        {messages.length === 0 && (
          <p className="text-center text-muted-foreground text-sm mt-8">
            Enter a topic and keywords to start.
          </p>
        )}
        {messages.map((msg, i) => (
          <div key={i} className={cn("flex", msg.role === "user" ? "justify-end" : "justify-start")}>
            <div className={cn(
              "max-w-[85%] rounded-lg px-3 py-2 text-sm whitespace-pre-wrap",
              msg.role === "user"
                ? "bg-primary text-primary-foreground"
                : "bg-muted text-foreground"
            )}>
              {msg.content}
              {msg.role === "assistant" && msg.content.startsWith("Error:") && (
                <Button
                  variant="outline"
                  size="sm"
                  className="mt-2 text-xs"
                  onClick={() => handleSend(lastMessage)}
                  disabled={isStreaming}
                >
                  Retry
                </Button>
              )}
            </div>
          </div>
        ))}
        <div ref={bottomRef} />
      </div>

      {/* Input area */}
      <div className="border-t p-3 flex gap-2 items-end shrink-0">
        <Textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Enter topic and keywords…"
          rows={2}
          disabled={isStreaming}
          className="resize-none flex-1 text-sm"
        />
        <Button
          onClick={() => handleSend()}
          disabled={!input.trim() || isStreaming}
          size="icon"
          aria-label="Send"
        >
          {isStreaming ? <Loader2 className="h-4 w-4 animate-spin" /> : <Send className="h-4 w-4" />}
        </Button>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend && npx tsc --noEmit 2>&1 | grep "ChatInterface" | head -5
  </verify>
  <done>ChatInterface.tsx compiles without TypeScript errors; messages render with correct role styling; input submits on Enter and button click; retry button appears on error messages; isStreaming disables input</done>
</task>

<task type="auto">
  <name>Task 2: EditorPane, CheckpointPanel, and main page layout</name>
  <files>
    frontend/src/components/EditorPane.tsx
    frontend/src/components/CheckpointPanel.tsx
    frontend/src/app/page.tsx
  </files>
  <action>
Create `frontend/src/components/EditorPane.tsx`:
Wraps `@uiw/react-md-editor` in controlled mode. Reads `draft` from Zustand store. Tokens stream in via store.appendDraftToken — the editor updates as each token arrives.

**Pitfall 7 mitigation:** Use `useTransition` to mark draft appends as non-urgent so React can batch them. Since tokens come at ~30/sec, test for lag and if present, apply requestAnimationFrame batching (comment with the pitfall reference).

**Critical import:** Must include `import "@uiw/react-md-editor/markdown-editor.css"` and wrap in `data-color-mode="light"` div to avoid CSS conflicts with Tailwind v4.

```tsx
"use client";
import dynamic from "next/dynamic";
import "@uiw/react-md-editor/markdown-editor.css";
import { useChatStore } from "@/store/chatStore";

// Dynamic import required — @uiw/react-md-editor uses browser APIs (no SSR)
const MDEditor = dynamic(() => import("@uiw/react-md-editor"), { ssr: false });

export function EditorPane() {
  const { draft, setDraft, isStreaming } = useChatStore();

  if (!draft && !isStreaming) {
    return (
      <div className="flex-1 flex items-center justify-center text-muted-foreground text-sm p-8">
        Draft will appear here as it is generated.
      </div>
    );
  }

  return (
    <div className="flex-1 overflow-hidden flex flex-col" data-color-mode="light">
      <MDEditor
        value={draft}
        onChange={(val) => setDraft(val ?? "")}
        height="100%"
        preview="live"
        style={{ flex: 1, overflow: "hidden" }}
      />
    </div>
  );
}
```

Create `frontend/src/components/CheckpointPanel.tsx`:
Renders only when `hitlPause` is non-null. Shows Approve, Approve+Save (checkpoint 2 only), and Reject buttons.

**Locked UX decisions from CONTEXT.md:**
- Reject flow is chat-style: Reject button POSTs to resume with action="reject" AND adds an agent message ("What would you like to change?"), then sets focus to the chat input. The user types their feedback in the normal chat input, which is then sent via a regular message to the stream.
- Iterations remaining counter is shown near Reject button at Checkpoint 2 only (checkpoint_id = "cp2" or similar)

**Implementation note:** For the chat-style reject flow, Reject sends `resumeStream(threadId, "reject", null)` immediately — the agent will respond with an assistant message asking for feedback. The user then types in the chat input normally. This means no separate feedback textarea is needed (per the locked decision: "focus moves to the normal chat input for the user's reply").

```tsx
"use client";
import { useChatStore } from "@/store/chatStore";
import { useSession } from "@/hooks/useSession";
import { resumeStream } from "@/hooks/useStream";
import { Button } from "@/components/ui/button";
import { CheckCircle2, XCircle, SaveAll } from "lucide-react";
import { cn } from "@/lib/utils";

export function CheckpointPanel() {
  const { hitlPause, isStreaming } = useChatStore();
  const { threadId, persistThreadId } = useSession();

  if (!hitlPause || isStreaming) return null;

  const isCheckpoint2 = hitlPause.checkpoint_id === "cp2" ||
    hitlPause.checkpoint_id === "checkpoint_2";
  const iterationsRemaining = hitlPause.iterations_remaining;

  const handleApprove = async () => {
    if (!threadId) return;
    await resumeStream(threadId, "approve", null, persistThreadId);
  };

  const handleApproveSave = async () => {
    if (!threadId) return;
    await resumeStream(threadId, "approve_save", null, persistThreadId);
  };

  const handleReject = async () => {
    if (!threadId) return;
    // Chat-style reject: send reject action, agent responds asking what to change,
    // user replies in the normal chat input (locked UX decision from CONTEXT.md)
    await resumeStream(threadId, "reject", null, persistThreadId);
  };

  return (
    <div className="border rounded-lg p-3 bg-muted/30 mx-4 mb-3 flex items-center gap-2 flex-wrap">
      <span className="text-xs text-muted-foreground mr-auto">
        {isCheckpoint2 ? "Review the draft" : "Review and approve to continue"}
      </span>

      <Button
        variant="default"
        size="sm"
        onClick={handleApprove}
        disabled={isStreaming}
        className="gap-1.5"
      >
        <CheckCircle2 className="h-3.5 w-3.5" />
        Approve
      </Button>

      {isCheckpoint2 && (
        <Button
          variant="default"
          size="sm"
          onClick={handleApproveSave}
          disabled={isStreaming}
          className="gap-1.5 bg-green-600 hover:bg-green-700"
        >
          <SaveAll className="h-3.5 w-3.5" />
          Approve &amp; Save
        </Button>
      )}

      <div className="flex items-center gap-1.5">
        <Button
          variant="outline"
          size="sm"
          onClick={handleReject}
          disabled={isStreaming}
          className="gap-1.5 text-destructive border-destructive/40 hover:bg-destructive/10"
        >
          <XCircle className="h-3.5 w-3.5" />
          Reject
        </Button>
        {isCheckpoint2 && iterationsRemaining !== undefined && (
          <span className="text-xs text-muted-foreground">
            {iterationsRemaining} of 3 attempts remaining
          </span>
        )}
      </div>
    </div>
  );
}
```

Update `frontend/src/app/page.tsx` to compose the full main view:
- StageProgress at the very top (from Plan 03)
- Below: two-column split (chat left ~40%, editor right ~60%)
- CheckpointPanel appears above the editor when hitlPause is non-null
- Use `flex h-full` layout to fill available viewport height

```tsx
import { StageProgress } from "@/components/StageProgress";
import { ChatInterface } from "@/components/ChatInterface";
import { EditorPane } from "@/components/EditorPane";
import { CheckpointPanel } from "@/components/CheckpointPanel";

export default function Home() {
  return (
    <div className="flex flex-col h-full overflow-hidden">
      <StageProgress />
      <div className="flex flex-1 min-h-0 overflow-hidden">
        {/* Chat column — 40% width */}
        <div className="w-[40%] min-w-0 flex flex-col border-r overflow-hidden">
          <ChatInterface />
        </div>
        {/* Editor column — 60% width */}
        <div className="flex-1 flex flex-col min-w-0 overflow-hidden">
          <CheckpointPanel />
          <EditorPane />
        </div>
      </div>
    </div>
  );
}
```
  </action>
  <verify>
    cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend && npx tsc --noEmit 2>&1 | head -15 && npm run build 2>&1 | tail -8
  </verify>
  <done>All three files compile without TypeScript errors; EditorPane uses dynamic import with ssr:false; CheckpointPanel shows Approve+Save only for checkpoint_2; iterations counter appears; page.tsx composes all components; build succeeds</done>
</task>

</tasks>

<verification>
1. `npm run dev` — open localhost:3000; see two-column layout: chat left, empty editor right
2. StageProgress shows at top (hidden initially since stage=idle and not streaming)
3. Type a message in chat input, press Enter — message appears in chat list
4. Simulate HITL pause: open browser console and run `window.__chatStore?.setHitlPause({checkpoint_id: "cp2", type: "approve_reject", iterations_remaining: 2})` — CheckpointPanel appears above editor with Approve, Approve+Save, Reject buttons and "2 of 3 attempts remaining"
5. EditorPane shows placeholder until draft is populated
6. `npm run build` passes with no errors
</verification>

<success_criteria>
- Two-column layout: 40% chat | 60% editor, filling full viewport height
- ChatInterface: message list with user/assistant styling, textarea input submitting on Enter, spinner during streaming, retry button on error messages
- EditorPane: @uiw/react-md-editor loaded via dynamic import (no SSR); draft value from Zustand; live preview mode
- CheckpointPanel: hidden when hitlPause is null; shows Approve + Reject always; shows Approve+Save + iterations counter only for checkpoint_2; Reject uses chat-style flow (no separate feedback textarea)
- TypeScript strict-mode compile passes; Next.js build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-api-and-frontend/03-04-SUMMARY.md`
</output>
