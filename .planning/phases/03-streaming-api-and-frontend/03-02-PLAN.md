---
phase: 03-streaming-api-and-frontend
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/package.json
  - frontend/src/store/chatStore.ts
  - frontend/src/hooks/useStream.ts
  - frontend/src/hooks/useSession.ts
  - frontend/src/lib/sse.ts
autonomous: true
requirements:
  - UI-07

must_haves:
  truths:
    - "Next.js 15 app exists in the /frontend directory and runs with npm run dev"
    - "Zustand store (chatStore) holds all streaming state: mode, threadId, stage, draft, messages, hitlPause, isStreaming"
    - "useStream hook sends POST to FastAPI /api/chat/stream and parses SSE events, updating the store on each event"
    - "useSession hook reads and writes threadId to sessionStorage under key bond_thread_id"
    - "SSE chunk boundary splitting is handled (lines buffered until double newline)"
  artifacts:
    - path: "frontend/src/store/chatStore.ts"
      provides: "Zustand store with all streaming state and actions"
      exports: ["useChatStore"]
    - path: "frontend/src/hooks/useStream.ts"
      provides: "startStream and resumeStream functions for SSE consumption"
      exports: ["startStream", "resumeStream"]
    - path: "frontend/src/hooks/useSession.ts"
      provides: "sessionStorage-backed threadId management"
      exports: ["useSession"]
    - path: "frontend/src/lib/sse.ts"
      provides: "SSE line-buffer parser that handles chunk boundary splitting"
      exports: ["parseSSEChunk", "SSEParser"]
  key_links:
    - from: "frontend/src/hooks/useStream.ts"
      to: "http://localhost:8000/api/chat/stream"
      via: "fetch POST with ReadableStream"
      pattern: "fetch.*api/chat/stream"
    - from: "frontend/src/hooks/useStream.ts"
      to: "frontend/src/store/chatStore.ts"
      via: "useChatStore.getState() calls on each SSE event"
      pattern: "useChatStore.getState"
    - from: "frontend/src/hooks/useSession.ts"
      to: "sessionStorage"
      via: "getItem/setItem bond_thread_id"
      pattern: "sessionStorage.*bond_thread_id"
---

<objective>
Bootstrap the Next.js 15 frontend project and build the core streaming infrastructure: Zustand state store, SSE consumption hooks, and session persistence.

Purpose: Every frontend UI component in Plans 03, 04, and 05 depends on this foundation. The store, stream hooks, and session hook are the wiring between SSE events from FastAPI and the React component tree.
Output: A running Next.js dev server with installed dependencies and a tested streaming layer that correctly parses all 7 SSE event types into Zustand state.
</objective>

<execution_context>
@/Users/franciszekmarzynski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/franciszekmarzynski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-streaming-api-and-frontend/03-RESEARCH.md
@.planning/phases/03-streaming-api-and-frontend/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bootstrap Next.js 15 project with all dependencies</name>
  <files>
    frontend/package.json
    frontend/src/app/globals.css
    frontend/tsconfig.json
  </files>
  <action>
Run from the repository root (not from within frontend/):

```bash
# Create Next.js app
npx create-next-app@latest frontend \
  --typescript \
  --tailwind \
  --eslint \
  --app \
  --src-dir \
  --import-alias "@/*" \
  --no-git

cd frontend

# Initialize shadcn/ui (detects Tailwind v4 automatically, generates CSS-first config in globals.css)
npx shadcn@latest init --defaults

# Add shadcn components used in this phase
npx shadcn@latest add button card switch progress separator input textarea badge

# Install project-specific dependencies
npm install @uiw/react-md-editor zustand lucide-react
npm install --save-dev @types/node
```

**Critical:** Tailwind v4 is CSS-first — there is NO `tailwind.config.js`. Configuration lives in `src/app/globals.css` via `@import "tailwindcss"`. Do NOT create `tailwind.config.js`. Do NOT copy any v3 patterns.

After installation, verify the `frontend/package.json` contains:
- `next: ^15.x`
- `react: ^19.x`
- `@uiw/react-md-editor`
- `zustand`
- `lucide-react`
- `tailwindcss: ^4.x`

Set `NEXT_PUBLIC_API_URL=http://localhost:8000` in `frontend/.env.local`:
```
NEXT_PUBLIC_API_URL=http://localhost:8000
```
  </action>
  <verify>
    cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend && npm run build 2>&1 | tail -5
  </verify>
  <done>Next.js build succeeds; package.json has all required dependencies; .env.local contains NEXT_PUBLIC_API_URL</done>
</task>

<task type="auto">
  <name>Task 2: Zustand store and SSE hooks</name>
  <files>
    frontend/src/store/chatStore.ts
    frontend/src/hooks/useStream.ts
    frontend/src/hooks/useSession.ts
    frontend/src/lib/sse.ts
  </files>
  <action>
Create `frontend/src/lib/sse.ts` — SSE chunk boundary parser (handles Pitfall 3 from RESEARCH.md):
```typescript
// Handles SSE chunk boundary splitting: accumulates lines, emits complete events
export interface SSEEvent {
  event: string;
  data: string;
}

export class SSEParser {
  private buffer = "";

  feed(chunk: string): SSEEvent[] {
    this.buffer += chunk;
    const events: SSEEvent[] = [];
    const parts = this.buffer.split("\n\n");
    // Last part may be incomplete — keep it in buffer
    this.buffer = parts.pop() ?? "";

    for (const part of parts) {
      const lines = part.split("\n");
      let eventType = "message";
      let dataLines: string[] = [];
      for (const line of lines) {
        if (line.startsWith("event: ")) {
          eventType = line.slice(7).trim();
        } else if (line.startsWith("data: ")) {
          dataLines.push(line.slice(6));
        }
      }
      if (dataLines.length > 0) {
        events.push({ event: eventType, data: dataLines.join("\n") });
      }
    }
    return events;
  }
}
```

Create `frontend/src/store/chatStore.ts` — Zustand store (verbatim from RESEARCH.md code examples, expanded with addMessage):
```typescript
"use client";
import { create } from "zustand";

export type Stage = "idle" | "research" | "structure" | "writing" | "done" | "error";
export type StageStatus = "pending" | "running" | "complete";
export type HitlPause = {
  checkpoint_id: string;
  type: string;
  iterations_remaining?: number;
} | null;

export interface ChatMessage {
  role: "user" | "assistant";
  content: string;
}

interface ChatStore {
  mode: "author" | "shadow";
  threadId: string | null;
  stage: Stage;
  stageStatus: Record<Stage, StageStatus>;
  draft: string;
  messages: ChatMessage[];
  hitlPause: HitlPause;
  isStreaming: boolean;
  // Actions
  setMode: (mode: "author" | "shadow") => void;
  setThreadId: (id: string | null) => void;
  setStage: (stage: Stage, status: StageStatus) => void;
  appendDraftToken: (token: string) => void;
  setDraft: (draft: string) => void;
  setHitlPause: (pause: HitlPause) => void;
  setStreaming: (v: boolean) => void;
  addMessage: (msg: ChatMessage) => void;
  resetSession: () => void;
}

const initialStageStatus: Record<Stage, StageStatus> = {
  idle: "pending",
  research: "pending",
  structure: "pending",
  writing: "pending",
  done: "pending",
  error: "pending",
};

export const useChatStore = create<ChatStore>((set) => ({
  mode: "author",
  threadId: null,
  stage: "idle",
  stageStatus: { ...initialStageStatus },
  draft: "",
  messages: [],
  hitlPause: null,
  isStreaming: false,
  setMode: (mode) => set({ mode }),
  setThreadId: (threadId) => set({ threadId }),
  setStage: (stage, status) =>
    set((s) => ({ stage, stageStatus: { ...s.stageStatus, [stage]: status } })),
  appendDraftToken: (token) => set((s) => ({ draft: s.draft + token })),
  setDraft: (draft) => set({ draft }),
  setHitlPause: (hitlPause) => set({ hitlPause }),
  setStreaming: (isStreaming) => set({ isStreaming }),
  addMessage: (msg) => set((s) => ({ messages: [...s.messages, msg] })),
  resetSession: () =>
    set({ threadId: null, stage: "idle", stageStatus: { ...initialStageStatus }, draft: "", messages: [], hitlPause: null, isStreaming: false }),
}));
```

Create `frontend/src/hooks/useSession.ts`:
```typescript
"use client";
import { useEffect } from "react";
import { useChatStore } from "@/store/chatStore";

const STORAGE_KEY = "bond_thread_id";

export function useSession() {
  const { threadId, setThreadId, resetSession } = useChatStore();

  useEffect(() => {
    const stored = sessionStorage.getItem(STORAGE_KEY);
    if (stored) setThreadId(stored);
  }, [setThreadId]);

  const persistThreadId = (id: string) => {
    sessionStorage.setItem(STORAGE_KEY, id);
    setThreadId(id);
  };

  const newSession = () => {
    sessionStorage.removeItem(STORAGE_KEY);
    resetSession();
  };

  return { threadId, persistThreadId, newSession };
}
```

Create `frontend/src/hooks/useStream.ts`:
```typescript
"use client";
import { useChatStore } from "@/store/chatStore";
import { SSEParser } from "@/lib/sse";

const API_URL = process.env.NEXT_PUBLIC_API_URL ?? "http://localhost:8000";

async function consumeStream(
  response: Response,
  onThreadId: (id: string) => void
): Promise<void> {
  const store = useChatStore.getState();
  const parser = new SSEParser();
  const reader = response.body!
    .pipeThrough(new TextDecoderStream())
    .getReader();

  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      if (!value) continue;

      const events = parser.feed(value);
      for (const { event, data } of events) {
        try {
          const parsed = JSON.parse(data);
          switch (event) {
            case "thread_id":
              onThreadId(parsed.thread_id);
              break;
            case "token":
              store.appendDraftToken(parsed.token);
              break;
            case "stage":
              store.setStage(parsed.stage, parsed.status);
              break;
            case "message":
              store.addMessage({ role: "assistant", content: parsed.content });
              break;
            case "hitl_pause":
              store.setHitlPause({
                checkpoint_id: parsed.checkpoint_id,
                type: parsed.type,
                iterations_remaining: parsed.iterations_remaining,
              });
              store.setStreaming(false);
              return; // Stream ends at HITL pause
            case "error":
              store.setStage("error", "running");
              store.addMessage({ role: "assistant", content: `Error: ${parsed.message}` });
              store.setStreaming(false);
              return;
            case "done":
              store.setStage("done", "complete");
              store.setStreaming(false);
              return;
          }
        } catch {
          // Skip malformed JSON — log in development
          if (process.env.NODE_ENV === "development") {
            console.warn("SSE parse error:", data);
          }
        }
      }
    }
  } finally {
    reader.releaseLock(); // Always release to avoid memory leak
  }
}

export async function startStream(message: string, threadId: string | null, mode: "author" | "shadow", onThreadId: (id: string) => void): Promise<void> {
  const store = useChatStore.getState();
  store.setStreaming(true);
  store.addMessage({ role: "user", content: message });

  const response = await fetch(`${API_URL}/api/chat/stream`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ message, thread_id: threadId, mode }),
  });

  if (!response.ok) {
    store.addMessage({ role: "assistant", content: "Connection error. Please try again." });
    store.setStreaming(false);
    return;
  }

  await consumeStream(response, onThreadId);
}

export async function resumeStream(
  threadId: string,
  action: "approve" | "approve_save" | "reject",
  feedback: string | null,
  onThreadId: (id: string) => void
): Promise<void> {
  const store = useChatStore.getState();
  store.setHitlPause(null);
  store.setStreaming(true);

  const response = await fetch(`${API_URL}/api/chat/resume`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ thread_id: threadId, action, feedback }),
  });

  if (!response.ok) {
    store.addMessage({ role: "assistant", content: "Resume error. Please try again." });
    store.setStreaming(false);
    return;
  }

  await consumeStream(response, onThreadId);
}
```
  </action>
  <verify>
    cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend && npx tsc --noEmit 2>&1 | head -20
  </verify>
  <done>TypeScript compilation passes with no errors on all four files; useChatStore, startStream, resumeStream, useSession are exported correctly; SSEParser handles split chunks</done>
</task>

</tasks>

<verification>
1. `cd /Users/franciszekmarzynski/Downloads/Bond-agent/frontend && npm run dev` starts without errors
2. `npx tsc --noEmit` passes with zero TypeScript errors
3. `npm run build` succeeds (no build-time errors)
4. `node -e "const s = require('./src/lib/sse'); console.log('sse ok')"` (or equivalent TSX import check)
5. Inspect `src/store/chatStore.ts` — all 7 event types handled in useStream.ts (thread_id, token, stage, message, hitl_pause, error, done)
</verification>

<success_criteria>
- Next.js 15 dev server starts on port 3000
- All dependencies installed: @uiw/react-md-editor, zustand, lucide-react, shadcn components
- Tailwind v4 CSS-first config in globals.css (no tailwind.config.js)
- chatStore.ts exports useChatStore with mode, threadId, stage, draft, messages, hitlPause, isStreaming
- useStream.ts handles all SSE events and always calls reader.releaseLock() in finally block
- useSession.ts persists threadId to sessionStorage under bond_thread_id
- SSEParser buffers incomplete chunks across read() calls
- TypeScript strict-mode compile passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-streaming-api-and-frontend/03-02-SUMMARY.md`
</output>
